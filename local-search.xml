<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>高地特供版CSAPP Bomb Lab全流程攻略</title>
    <link href="/2025/02/24/nudtbomblab/"/>
    <url>/2025/02/24/nudtbomblab/</url>
    
    <content type="html"><![CDATA[<p>这篇文章记录高地CSAPP课程Bomblab实验操作流程，仅供参考交流（答案是随机生成的和学号相关）。</p><p>笔者实验环境为Archlinux&#x2F;CachyOS，使用lldb作为调试器（和gdb操作差不多），其余用到的工具主要为objdump，strings，neovim&#x2F;helix和zellij，全程开源环境不使用IDA。</p><h2 id="Phase-1"><a href="#Phase-1" class="headerlink" title="Phase_1"></a><strong>Phase_1</strong></h2><h3 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a><strong>静态分析</strong></h3><h4 id="strings扫描"><a href="#strings扫描" class="headerlink" title="strings扫描"></a><strong><code>strings</code>扫描</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">strings bomb_linux<br></code></pre></td></tr></table></figure><p>先用strings寻找可能与<code>phase_1</code>相关的字符串或函数名，运气好说不定能直接找到密码毕竟是第一题。<br><img src="/images/phase1_strings.png" alt="strings"></p><ul><li>结果没有明文密码无法直接秒掉第一问，可惜。</li><li>但是找到<code>GenerateRandomString</code>函数可能与密码生成相关。</li></ul><h4 id="用objdump反汇编"><a href="#用objdump反汇编" class="headerlink" title="用objdump反汇编"></a><strong>用<code>objdump</code>反汇编</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">objdump -d bomb_linux &gt; bomb.asm<br></code></pre></td></tr></table></figure><p>搜索<code>GenerateRandomString</code>和<code>phase_1</code>函数的汇编代码。<br>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs assembly">401b53 &lt;phase_1&gt;:<br>  401b53: endbr64<br>  401b57: push   %rbp<br>  401b58: mov    %rsp,%rbp<br>  401b5b: sub    $0x20,%rsp<br>  401b5f: mov    %rdi,-0x18(%rbp)<br>  401b63: lea    -0xb(%rbp),%rax<br>  401b67: mov    %rax,%rdi<br>  401b6a: callq  401ac1 &lt;GenerateRandomString&gt;  # 调用密码生成函数<br>  401b6f: lea    -0xb(%rbp),%rdx                # 生成的字符串地址%rbp-0xb存入%rdx，即密码存储位置<br>  401b73: mov    -0x18(%rbp),%rax<br>  401b77: mov    %rdx,%rsi<br>  401b7a: mov    %rax,%rdi<br>  401b7d: callq  401c0c &lt;string_compare&gt;        # 调用字符串比较函数<br>  401b82: test   %eax,%eax<br>  401b84: je     401b8d &lt;phase_1+0x3a&gt;<br>  401b86: callq  401d67 &lt;explode_bomb&gt;          # 比较失败则引爆炸弹<br></code></pre></td></tr></table></figure></p><ul><li><code>phase_1</code>调用<code>GenerateRandomString</code>生成一个字符串。</li><li>用户输入的字符串需要与此生成的字符串完全匹配。</li></ul><hr><h3 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a><strong>动态调试</strong></h3><p><img src="/images/phase1.png" alt="phase_1"><br>下面是phase_1求解的完整流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lldb">lldb bomb_linux &lt;你的学号后六位&gt;<br>(lldb) b phase_1                    # 在phase_1入口断点<br>(lldb) run                          # 从入口开始执行<br>请输入第1级的密码：114514           # 随便输入触发断点<br>(lldb) b 0x401b6f                   # 在GenerateRandomString返回后断点<br>(lldb) continue                     # 继续执行<br>(lldb) x/s $rbp - 0xb               # 计算字符串地址（-0xb偏移量）<br>0x7fffffffdaf5: &quot;mJHurpQZtY&quot;        # 轻松拿下，这里是根据学号伪随机生成的哦<br></code></pre></td></tr></table></figure><p>将得到的密码保存入bomb_&lt;学号后六位&gt;.txt即可，避免后续重复输入。</p><hr><h2 id="Phase-2"><a href="#Phase-2" class="headerlink" title="Phase_2"></a><strong>Phase_2</strong></h2><h3 id="静态分析-1"><a href="#静态分析-1" class="headerlink" title="静态分析"></a><strong>静态分析</strong></h3><p>这道题目还是比较一目了然的，观察<code>phase_2</code>代码不难发现其实构建了一张跳转表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0000000000401b8e &lt;phase_2&gt;:<br>  401b8e:f3 0f 1e fa          endbr64<br>  401b92:55                   push   %rbp<br>  401b93:48 89 e5             mov    %rsp,%rbp<br>  401b96:48 83 ec 10          sub    $0x10,%rsp<br>  401b9a:48 89 7d f8          mov    %rdi,-0x8(%rbp)<br>  401b9e:bf 10 00 00 00       mov    $0x10,%edi<br>  401ba3:e8 05 fb ff ff       call   4016ad &lt;GenerateRandomNumber&gt;<br>  401ba8:48 8b 05 71 6c 00 00 mov    0x6c71(%rip),%rax        # 408820 &lt;rand_div&gt;<br>  401baf:48 83 f8 0f          cmp    $0xf,%rax<br>  401bb3:0f 87 16 01 00 00    ja     401ccf &lt;phase_2+0x141&gt;<br>  401bb9:48 8d 14 85 00 00 00 lea    0x0(,%rax,4),%rdx<br>  401bc0:00 <br>  401bc1:48 8d 05 4c 4a 00 00 lea    0x4a4c(%rip),%rax        # 406614 &lt;_IO_stdin_used+0x614&gt;<br>  401bc8:8b 04 02             mov    (%rdx,%rax,1),%eax<br>  401bcb:48 98                cltq<br>  401bcd:48 8d 15 40 4a 00 00 lea    0x4a40(%rip),%rdx        # 406614 &lt;_IO_stdin_used+0x614&gt;<br>  401bd4:48 01 d0             add    %rdx,%rax<br>  401bd7:3e ff e0             notrack jmp *%rax<br>  401bda:48 8b 45 f8          mov    -0x8(%rbp),%rax<br>  401bde:48 89 c7             mov    %rax,%rdi<br>  401be1:e8 f2 00 00 00       call   401cd8 &lt;phase_2_0&gt;<br>  401be6:e9 ea 00 00 00       jmp    401cd5 &lt;phase_2+0x147&gt;<br>  401beb:48 8b 45 f8          mov    -0x8(%rbp),%rax<br>  401bef:48 89 c7             mov    %rax,%rdi<br>  401bf2:e8 8b 01 00 00       call   401d82 &lt;phase_2_1&gt;<br>  401bf7:e9 d9 00 00 00       jmp    401cd5 &lt;phase_2+0x147&gt;<br>  401bfc:48 8b 45 f8          mov    -0x8(%rbp),%rax<br>  401c00:48 89 c7             mov    %rax,%rdi<br>  ...<br></code></pre></td></tr></table></figure><p>这里面需要注意的关键点是rand_div，它会决定你的跳转方向，而你的学号又决定了它的取值。然后是<code>GenerateRandomNumber</code>这个函数的原理需要了解一下，而这个函数将在跳转前后分别调用一次，第一次决定你的跳转方向，第二次则决定了你的密码线索。</p><hr><h3 id="动态调试-1"><a href="#动态调试-1" class="headerlink" title="动态调试"></a><strong>动态调试</strong></h3><p>理解原理就没什么难度了，自己找几个断点打好然后关注一下<code>rand_div</code>的值就好，观察自己的学号向哪个函数跳转并理解相应函数计算即可，比如我这里向<code>phase_2_14</code>跳转：<br><img src="/images/phase_2_14.png" alt="phase_2_14"></p><p>而除了<code>phase_2_14</code>还有其他函数也是非常好理解的，第二题依旧可以轻松拿下。</p><hr><h2 id="Phase-3"><a href="#Phase-3" class="headerlink" title="Phase_3"></a><strong>Phase_3</strong></h2><h3 id="静态分析-2"><a href="#静态分析-2" class="headerlink" title="静态分析"></a><strong>静态分析</strong></h3><p>和Phase_2一样开局先跳转尽可能防止同学们答案雷同互相帮助（bushi</p><p>本体其实没有什么好说的，这里我跳转的方向是<code>Phase_3_5</code>简要解释一下可供参考：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0000000000403001 &lt;phase_3_5&gt;:<br>  403001:f3 0f 1e fa          endbr64<br>  403005:55                   push   %rbp<br>  403006:48 89 e5             mov    %rsp,%rbp<br>  403009:48 83 ec 20          sub    $0x20,%rsp<br>  40300d:48 89 7d e8          mov    %rdi,-0x18(%rbp)<br>  403011:c7 45 fc 00 00 00 00 movl   $0x0,-0x4(%rbp)<br>  403018:c7 45 f8 00 00 00 00 movl   $0x0,-0x8(%rbp)<br>  40301f:48 8d 4d f0          lea    -0x10(%rbp),%rcx<br>  403023:48 8d 55 f4          lea    -0xc(%rbp),%rdx<br>  403027:48 8b 45 e8          mov    -0x18(%rbp),%rax<br>  40302b:48 8d 35 5a 36 00 00 lea    0x365a(%rip),%rsi        # 40668c &lt;_IO_stdin_used+0x68c&gt;<br>  403032:48 89 c7             mov    %rax,%rdi<br>  403035:b8 00 00 00 00       mov    $0x0,%eax<br>  40303a:e8 51 e1 ff ff       call   401190 &lt;__isoc99_sscanf@plt&gt;<br>  40303f:89 45 f8             mov    %eax,-0x8(%rbp)<br>  403042:83 7d f8 01          cmpl   $0x1,-0x8(%rbp)<br>  403046:7f 05                jg     40304d &lt;phase_3_5+0x4c&gt;<br>  403048:e8 a9 2b 00 00       call   405bf6 &lt;explode_bomb&gt;<br>  40304d:bf 08 00 00 00       mov    $0x8,%edi<br>  403052:e8 56 e6 ff ff       call   4016ad &lt;GenerateRandomNumber&gt;<br>  403057:8b 45 f4             mov    -0xc(%rbp),%eax<br>  40305a:48 63 d0             movslq %eax,%rdx<br>  40305d:48 8b 05 bc 57 00 00 mov    0x57bc(%rip),%rax        # 408820 &lt;rand_div&gt;<br>  403064:48 39 c2             cmp    %rax,%rdx<br>  403067:74 05                je     40306e &lt;phase_3_5+0x6d&gt;<br>  403069:e8 88 2b 00 00       call   405bf6 &lt;explode_bomb&gt;<br>  40306e:bf c8 00 00 00       mov    $0xc8,%edi<br>  403073:e8 35 e6 ff ff       call   4016ad &lt;GenerateRandomNumber&gt;<br>  403078:8b 45 f4             mov    -0xc(%rbp),%eax<br>  40307b:83 f8 07             cmp    $0x7,%eax<br>  40307e:0f 87 eb 00 00 00    ja     40316f &lt;phase_3_5+0x16e&gt;<br>  403084:89 c0                mov    %eax,%eax<br>  403086:48 8d 14 85 00 00 00 lea    0x0(,%rax,4),%rdx<br>  40308d:00 <br>  40308e:48 8d 05 9f 36 00 00 lea    0x369f(%rip),%rax        # 406734 &lt;_IO_stdin_used+0x734&gt;<br>  403095:8b 04 02             mov    (%rdx,%rax,1),%eax<br>  403098:48 98                cltq<br>  40309a:48 8d 15 93 36 00 00 lea    0x3693(%rip),%rdx        # 406734 &lt;_IO_stdin_used+0x734&gt;<br>  4030a1:48 01 d0             add    %rdx,%rax<br>  4030a4:3e ff e0             notrack jmp *%rax<br>  4030a7:48 8b 05 72 57 00 00 mov    0x5772(%rip),%rax        # 408820 &lt;rand_div&gt;<br>  4030ae:89 c2                mov    %eax,%edx<br>  4030b0:8b 45 fc             mov    -0x4(%rbp),%eax<br>  4030b3:01 d0                add    %edx,%eax<br>  4030b5:89 45 fc             mov    %eax,-0x4(%rbp)<br>  4030b8:bf c8 00 00 00       mov    $0xc8,%edi<br>  4030bd:e8 eb e5 ff ff       call   4016ad &lt;GenerateRandomNumber&gt;<br>  ...<br>  403174:8b 45 f0             mov    -0x10(%rbp),%eax<br>  403177:39 45 fc             cmp    %eax,-0x4(%rbp)          # 注意这里<br>  40317a:74 05                je     403181 &lt;phase_3_5+0x180&gt;<br>  40317c:e8 75 2a 00 00       call   405bf6 &lt;explode_bomb&gt;<br>  403181:90                   nop<br>  403182:c9                   leave<br>  403183:c3                   ret<br><br></code></pre></td></tr></table></figure><p>看起来一大堆很吓人对不对？实际上确实很吓人。</p><p>但是发现其中玄机后其实简单的没边，最终答案就藏在<code>0x403177</code>里面，前提是确保这一步前炸弹不爆炸（意识到要爆炸了直接<code>run</code>一下重开qwq）。</p><hr><h3 id="动态调试-2"><a href="#动态调试-2" class="headerlink" title="动态调试"></a><strong>动态调试</strong></h3><p>阅读<code>Phase_3_5</code>发现这一关其实需要两个输入，并且第一个输入必须是<code>rand_div</code>，这里建议通过<code>si</code>单步执行监控好<code>rand_div</code>值变化，确定正确结果后使用<code>run</code>重开正确输入第一个密码后才能进行下一步求解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lldb">(lldb) si<br>Process 13376 stopped<br>* thread #1, name = &#x27;bomb_linux&#x27;, stop reason = instruction step into<br>    frame #0: 0x000000000040317a bomb_linux`phase_3_5 + 377<br>bomb_linux`phase_3_5:<br>-&gt;  0x40317a &lt;+377&gt;: je     0x403181       ; &lt;+384&gt;<br>    0x40317c &lt;+379&gt;: callq  0x405bf6       ; explode_bomb<br>    0x403181 &lt;+384&gt;: nop<br>    0x403182 &lt;+385&gt;: leave<br>(lldb) x/wx $rbp-0x4<br>0x7fffffffdb0c: 0xffffffd7<br></code></pre></td></tr></table></figure><p>例如这里我可以打印出第二个值结合第一个值得到第三关正确结果。</p><hr><h2 id="Phase-4"><a href="#Phase-4" class="headerlink" title="Phase_4"></a><strong>Phase_4</strong></h2><h3 id="静态分析-3"><a href="#静态分析-3" class="headerlink" title="静态分析"></a><strong>静态分析</strong></h3><p>本题依旧开局跳转，笔者的跳转方向是<code>phase_4_01</code>，如何跳转不再强调关注<code>rand_div</code>的值即可，下面请D指导解读一下<code>phase_4_01</code>的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0000000000404895 &lt;phase_4_01&gt;:<br>  ; 函数入口，初始化栈帧<br>  404895:f3 0f 1e fa          endbr64 <br>  404899:55                   push   %rbp<br>  40489a:48 89 e5             mov    %rsp,%rbp<br>  40489d:48 83 ec 70          sub    $0x70,%rsp    ; 分配栈空间<br><br>  ; 初始化斐波那契数组（F(10)~F(24)的十六进制值）<br>  4048a1:48 89 7d 98          mov    %rdi,-0x68(%rbp) ; 保存输入字符串指针<br>  4048a5:c7 45 b0 37 00 00 00 movl   $0x37,-0x50(%rbp)   ; F(10)=55<br>  4048ac:c7 45 b4 59 00 00 00 movl   $0x59,-0x4c(%rbp)   ; F(11)=89<br>  4048b3:c7 45 b8 90 00 00 00 movl   $0x90,-0x48(%rbp)   ; F(12)=144<br>  4048ba:c7 45 bc e9 00 00 00 movl   $0xe9,-0x44(%rbp)   ; F(13)=233<br>  4048c1:c7 45 c0 79 01 00 00 movl   $0x179,-0x40(%rbp)  ; F(14)=377<br>  4048c8:c7 45 c4 62 02 00 00 movl   $0x262,-0x3c(%rbp)  ; F(15)=610<br>  4048cf:c7 45 c8 db 03 00 00 movl   $0x3db,-0x38(%rbp)  ; F(16)=987<br>  4048d6:c7 45 cc 3d 06 00 00 movl   $0x63d,-0x34(%rbp)  ; F(17)=1597<br>  4048dd:c7 45 d0 18 0a 00 00 movl   $0xa18,-0x30(%rbp)  ; F(18)=2584<br>  4048e4:c7 45 d4 55 10 00 00 movl   $0x1055,-0x2c(%rbp) ; F(19)=4181<br>  4048eb:c7 45 d8 6d 1a 00 00 movl   $0x1a6d,-0x28(%rbp) ; F(20)=6765<br>  4048f2:c7 45 dc c2 2a 00 00 movl   $0x2ac2,-0x24(%rbp) ; F(21)=10946<br>  4048f9:c7 45 e0 2f 45 00 00 movl   $0x452f,-0x20(%rbp) ; F(22)=17711<br>  404900:c7 45 e4 f1 6f 00 00 movl   $0x6ff1,-0x1c(%rbp) ; F(23)=28657<br>  404907:c7 45 e8 20 b5 00 00 movl   $0xb520,-0x18(%rbp) ; F(24)=46368<br><br>  ; 读取输入到局部变量（格式为&quot;%d&quot;）<br>  40490e:48 8d 55 ac          lea    -0x54(%rbp),%rdx    ; 输入存储地址<br>  404912:48 8b 45 98          mov    -0x68(%rbp),%rax   ; 输入字符串<br>  404916:48 8d 0d 93 1f 00 00 lea    0x1f93(%rip),%rcx   ; 格式字符串&quot;%d&quot;<br>  40491d:48 89 ce             mov    %rcx,%rsi<br>  404920:48 89 c7             mov    %rax,%rdi<br>  404923:b8 00 00 00 00       mov    $0x0,%eax<br>  404928:e8 63 c8 ff ff       call   401190 &lt;__isoc99_sscanf@plt&gt;<br><br>  ; 验证输入有效性（必须为1个正数）<br>  40492d:89 45 fc             mov    %eax,-0x4(%rbp)    ; sscanf返回值<br>  404930:83 7d fc 01          cmpl   $0x1,-0x4(%rbp)   ; 检查是否读取1个参数<br>  404934:75 07                jne    40493d &lt;phase_4_01+0xa8&gt; ; 失败则爆炸<br>  404936:8b 45 ac             mov    -0x54(%rbp),%eax ; 获取输入值N<br>  404939:85 c0                test   %eax,%eax         ; 检查N &gt; 0<br>  40493b:7f 05                jg     404942 &lt;phase_4_01+0xad&gt;<br>  40493d:e8 b4 12 00 00       call   405bf6 &lt;explode_bomb&gt;<br><br>  ; 检查输入值上限（必须 &gt; 1999）<br>  404942:8b 45 ac             mov    -0x54(%rbp),%eax <br>  404945:3d cf 07 00 00       cmp    $0x7cf,%eax       ; 1999的十六进制<br>  40494a:7f 05                jg     404951 &lt;phase_4_01+0xbc&gt; ; N &gt; 1999?<br>  40494c:e8 a5 12 00 00       call   405bf6 &lt;explode_bomb&gt;<br><br>  ; 计算 N/2000（通过定点数乘法优化）<br>  404951:8b 45 ac             mov    -0x54(%rbp),%eax  ; 输入值N<br>  404954:48 63 d0             movslq %eax,%rdx        ; 符号扩展<br>  404957:48 69 d2 d3 4d 62 10 imul   $0x10624dd3,%rdx,%rdx ; 乘以274877907(≈2^32/2000)<br>  40495e:48 c1 ea 20          shr    $0x20,%rdx       ; 取高32位<br>  404962:c1 fa 07             sar    $0x7,%edx        ; 算术右移7位 → N/2000<br>  404965:c1 f8 1f             sar    $0x1f,%eax       ; 符号位扩展<br>  404968:89 c1                mov    %eax,%ecx        <br>  40496a:89 d0                mov    %edx,%eax        <br>  40496c:29 c8                sub    %ecx,%eax        ; 处理负数情况<br>  40496e:89 45 ac             mov    %eax,-0x54(%rbp) ; 保存k = N/2000<br><br>  ; 调用递归函数func4_0(k), 这个函数用于计算斐波那契数列<br>  404971:8b 45 ac             mov    -0x54(%rbp),%eax <br>  404974:89 c7                mov    %eax,%edi        ; 参数k<br>  404976:e8 ce fd ff ff       call   404749 &lt;func4_0&gt;  ; 返回值eax=F(k+1)<br>  40497b:89 45 f8             mov    %eax,-0x8(%rbp)  ; 保存结果<br><br>  ; 生成随机索引并验证结果<br>  40497e:bf 0f 00 00 00       mov    $0xf,%edi        ; 参数15<br>  404983:e8 25 cd ff ff       call   4016ad &lt;GenerateRandomNumber&gt; ; 生成0~14随机数<br>  404988:48 8b 05 91 3e 00 00 mov    0x3e91(%rip),%rax        # 408820 &lt;rand_div&gt; ; 获取随机索引<br>  40498f:8b 44 85 b0          mov    -0x50(%rbp,%rax,4),%eax ; 取数组[rand_div]的值<br>  404993:39 45 f8             cmp    %eax,-0x8(%rbp)  ; 比较func4_0(k) == 数组值？<br>  404996:74 05                je     40499d &lt;phase_4_01+0x108&gt;<br>  404998:e8 59 12 00 00       call   405bf6 &lt;explode_bomb&gt;<br></code></pre></td></tr></table></figure><p>所以相对还是很明了的，依旧是关注<code>rand_div</code>。</p><h3 id="动态调试-3"><a href="#动态调试-3" class="headerlink" title="动态调试"></a><strong>动态调试</strong></h3><p>先找出<code>rand_div</code>在最后判断前的取值，比如我下面的0xa：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs lldb">(lldb) si<br>Process 27027 stopped<br>* thread #1, name = &#x27;bomb_linux&#x27;, stop reason = instruction step into<br>    frame #0: 0x0000000000401719 bomb_linux`GenerateRandomNumber + 108<br>bomb_linux`GenerateRandomNumber:<br>-&gt;  0x401719 &lt;+108&gt;: movq   %rax, 0x7100(%rip) ; rand_div<br>    0x401720 &lt;+115&gt;: jmp    0x401723       ; &lt;+118&gt;<br>    0x401722 &lt;+117&gt;: nop<br>    0x401723 &lt;+118&gt;: popq   %rbp<br>(lldb) si<br>Process 27027 stopped<br>* thread #1, name = &#x27;bomb_linux&#x27;, stop reason = instruction step into<br>    frame #0: 0x0000000000401720 bomb_linux`GenerateRandomNumber + 115<br>bomb_linux`GenerateRandomNumber:<br>-&gt;  0x401720 &lt;+115&gt;: jmp    0x401723       ; &lt;+118&gt;<br>    0x401722 &lt;+117&gt;: nop<br>    0x401723 &lt;+118&gt;: popq   %rbp<br>    0x401724 &lt;+119&gt;: retq<br>(lldb) x/gx &amp;rand_div<br>0x00408820: 0x000000000000000a<br></code></pre></td></tr></table></figure><p>而当 <code>rand_div = 0xa</code>（即十进制 <strong>10</strong>）时，输入值 <code>N</code> 的计算步骤如下：</p><ul><li><p>数组索引 <strong>10</strong> 的值是 <strong>斐波那契数列第 20 项</strong>（<code>F(20) = 6765</code>）。</p></li><li><p><code>func4_0(k)</code> 实际计算的是 <strong>标准斐波那契数列的第 <code>k+1</code> 项</strong>（例如，<code>func4_0(0) = 1 = F(2)</code>） 需要满足：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">func4_0(k) = F(k+<span class="hljs-number">1</span>) = F(<span class="hljs-number">20</span>)<br></code></pre></td></tr></table></figure><p>解得：<br>k + 1 &#x3D; 20 → k &#x3D; 19</p></li><li><p><code>k = N / 2000</code> → <code>N = 2000 * k = 2000 * 19 = 38000</code>.<br>从而得解。<br><img src="/images/phase_4.png" alt="phase_4"></p></li></ul><hr><h2 id="Phase-Impossible"><a href="#Phase-Impossible" class="headerlink" title="Phase_Impossible"></a><strong>Phase_Impossible</strong></h2><p>Impossible？</p><p>从这道题开始偷懒了，掏出ghidra直接看c代码了解一下大概流程再去objdump看汇编：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">phase_impossible</span><span class="hljs-params">(<span class="hljs-type">char</span> *param_1)</span><br><br>&#123;<br>  <span class="hljs-type">int</span> iVar1;<br>  <span class="hljs-type">size_t</span> sVar2;<br>  undefined local_118 [<span class="hljs-number">256</span>];<br>  <span class="hljs-type">long</span> local_18;<br>  <span class="hljs-type">long</span> local_10;<br>  <br>  local_10 = GetTickCount();<br>  sVar2 = <span class="hljs-built_in">strlen</span>(param_1);<br>  <span class="hljs-keyword">if</span> ((sVar2 &lt; <span class="hljs-number">10</span>) || (sVar2 = <span class="hljs-built_in">strlen</span>(param_1), <span class="hljs-number">0x300</span> &lt; sVar2)) &#123;<br>    explode_bomb();<br>  &#125;<br>  <span class="hljs-built_in">memset</span>(local_118,<span class="hljs-number">0</span>,<span class="hljs-number">0x100</span>);<br>  tohex(local_118,param_1);<br>  GenerateRandomNumber(<span class="hljs-number">0x400</span>);<br>  iVar1 = check_buf_valid(local_118,rand_div &amp; <span class="hljs-number">0xffffffff</span>);<br>  <span class="hljs-keyword">if</span> (iVar1 == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">puts</span>(&amp;DAT_00406518);<br>    explode_bomb();<br>  &#125;<br>  GenerateRandomNumber(<span class="hljs-number">3</span>);<br>  <span class="hljs-keyword">if</span> (rand_div != <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> &lt; rand_div) <span class="hljs-keyword">goto</span> LAB_00401891;<br>    <span class="hljs-keyword">if</span> (rand_div == <span class="hljs-number">0</span>) &#123;<br>      goto_buf_0(local_118);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rand_div != <span class="hljs-number">1</span>) <span class="hljs-keyword">goto</span> LAB_00401891;<br>    goto_buf_1(local_118);<br>  &#125;<br>  goto_buf_2(local_118);<br>LAB_00401891:<br>  explode_bomb();<br>  GenerateRandomNumber(<span class="hljs-number">0x400</span>);<br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>)(<span class="hljs-type">int</span>)result != rand_div) &#123;<br>    <span class="hljs-built_in">printf</span>(&amp;DAT_00406560,rand_div,(ulong)result);<br>    explode_bomb();<br>  &#125;<br>  local_18 = GetTickCount();<br>  <span class="hljs-keyword">if</span> (<span class="hljs-number">1000</span> &lt; (ulong)(local_18 - local_10)) &#123;<br>    <span class="hljs-built_in">puts</span>(&amp;DAT_004065a8);<br>    explode_bomb();<br>  &#125;<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终任务还是很明确的，需要写一段机器码修改<code>result</code>的数值，但是注意要能通过<code>check_buf_valid</code>检测，并且最后指令必须是跳转到<code>0x401896</code>不然就会触发<code>phase_impossible</code>中<code>0x401891</code>处的<code>explode_bomb</code>函数，唯一的难点是跟踪<code>rand_div</code>的数值变化，建议使用<code>register write</code>来修改<code>check_buf_valid</code>的返回值使其强制通过然后监控<code>rand_div</code>每一次的数值变化（<code>x/gx &amp;rand_div</code>），记录好<code>rand_div</code>的结果后开始指令设计，需要满足：</p><ul><li>指令的异或和为<code>rand_div</code>第一次的数值末尾八位以通过检查;</li><li>修改<code>result</code>使其数值等于<code>rand_div</code>第三次数值;</li><li>跳转到<code>0x401896</code>避免炸弹;</li></ul><p> 如果前几问都完成了到这里应该是没有问题的。</p><hr><h2 id="Phase-Secret"><a href="#Phase-Secret" class="headerlink" title="Phase_Secret"></a><strong>Phase_Secret</strong></h2><p>隐藏彩蛋，并非隐藏。汇编里写的非常清楚：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0000000000401a8b &lt;phase_secret&gt;:<br>  401a8b:f3 0f 1e fa          endbr64<br>  401a8f:55                   push   %rbp<br>  401a90:48 89 e5             mov    %rsp,%rbp<br>  401a93:48 83 ec 10          sub    $0x10,%rsp<br>  401a97:48 89 7d f8          mov    %rdi,-0x8(%rbp)<br>  401a9b:48 8d 05 26 4b 00 00 lea    0x4b26(%rip),%rax        # 4065c8 &lt;_IO_stdin_used+0x5c8&gt;<br>  401aa2:48 89 c7             mov    %rax,%rdi<br>  401aa5:e8 76 f6 ff ff       call   401120 &lt;puts@plt&gt;<br>  401aaa:90                   nop<br>  401aab:c9                   leave<br>  401aac:c3                   ret<br></code></pre></td></tr></table></figure><p>注意到这段指令在原程序中完全没有执行说明是需要用户自己跳转的，也非常简单只需要在<code>phase_5</code>中设计指令时加一个要求跳转到<code>0x401a8b</code>即可。</p><p>完结<br><img src="/images/caseclosed.png" alt="Case Closed"></p>]]></content>
    
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>生活</tag>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Clonezilla备份和克隆系统</title>
    <link href="/2025/02/23/clonezilla/"/>
    <url>/2025/02/23/clonezilla/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/clonezilla.png" alt="Clonezilla官网"><br><a href="https://clonezilla.org/">Clonezilla</a>是一款非常好用的系统迁移工具，本文将介绍其基本用法（不包含网络迁移及Clonezilla服务器等进阶内容）以及在克隆Btrfs磁盘时遇到的问题解法。</p><hr><h3 id="零-事前准备："><a href="#零-事前准备：" class="headerlink" title="零.事前准备："></a><strong>零.事前准备</strong>：</h3><ul><li>下载Clonezilla Live镜像（ISO），制作启动U盘（有手就行）。</li><li>准备目标存储设备（如U盘，需要迁移的新硬盘等），确保有足够空间（建议大于源硬盘已用空间的1.2倍）。</li></ul><h3 id="一-备份镜像到硬盘（Device-to-Image）"><a href="#一-备份镜像到硬盘（Device-to-Image）" class="headerlink" title="一.备份镜像到硬盘（Device-to-Image）"></a><strong>一.备份镜像到硬盘（Device-to-Image）</strong></h3><p>这个模式可以将硬盘完整备份为一个镜像文件（可保存到本地硬盘、外置硬盘或网络存储）方便多机部署。注意如果只是将一个硬盘的系统完全克隆到新盘可以跳过此部分。</p><h4 id="步骤说明："><a href="#步骤说明：" class="headerlink" title="步骤说明："></a><strong>步骤说明</strong>：</h4><ol start="2"><li><p><strong>启动Clonezilla</strong>：</p><ul><li>插入U盘，重启电脑并从U盘启动。</li><li>选择默认选项（语言，键盘布局，Beginner模式）进入Clonezilla的TUI界面。</li></ul></li><li><p><strong>选择备份模式</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Choose mode:         选择 &quot;device-image&quot;（设备到镜像）<br>Mount storage media: 选择 &quot;local_dev&quot;（本地存储设备）<br></code></pre></td></tr></table></figure><ul><li>按提示挂载目标存储设备（注意这里选择的是你要存储镜像的设备且文件系统一般不限，如外置硬盘），确认路径（如 <code>/dev/sdb1</code>）。</li></ul></li><li><p><strong>配置备份参数</strong>：</p><ul><li><strong>源硬盘</strong>：选择需要备份的硬盘（如 <code>/dev/sda</code>）。</li><li><strong>镜像存储路径</strong>：指定目标位置（如外置硬盘的挂载目录）。</li><li><strong>镜像名称</strong>：自定义名称（如 <code>2025-img-rockylinux-2-21</code>）。</li><li><strong>压缩选项</strong>：默认即可，支持并行压缩加速。</li><li><strong>镜像分割</strong>：若目标存储设备为FAT32格式（单文件最大4GB），选择自动分割。</li></ul></li><li><p><strong>确认操作</strong>：</p><ul><li>检查提示信息，输入 <code>y</code> 开始备份。</li><li>完成后关机或重启。</li></ul></li><li><p><strong>镜像还原</strong>：和备份非常相似，只是选项换成restore to disk，顺着指引操作即可。</p></li></ol><hr><h3 id="二、直接克隆硬盘（Device-to-Device）"><a href="#二、直接克隆硬盘（Device-to-Device）" class="headerlink" title="二、直接克隆硬盘（Device-to-Device）"></a><strong>二、直接克隆硬盘（Device-to-Device）</strong></h3><p>将源硬盘完整克隆到目标硬盘（适合硬盘升级或快速迁移），比如笔者最近白嫖了一个三星的2T硬盘直接把原来512G硬盘里的CachyOS无损迁移了进去。</p><h4 id="步骤说明：-1"><a href="#步骤说明：-1" class="headerlink" title="步骤说明："></a><strong>步骤说明</strong>：</h4><ol><li><p><strong>准备工作</strong>：</p><ul><li>连接目标硬盘（需容量≥源硬盘已用空间，还原镜像操作也是如此，注意Clonezilla支持小分区到大分区迁移不支持大分区到小分区，后者出门右转Rsync）</li><li><strong>警告</strong>：目标硬盘数据将被覆盖，操作前如有需要务必备份重要数据！</li></ul></li><li><p><strong>启动Clonezilla</strong>：</p><ul><li>同上，从U盘启动进入Clonezilla界面。</li></ul></li><li><p><strong>选择克隆模式</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Choose mode:         选择 &quot;device-device&quot;（设备到设备）<br></code></pre></td></tr></table></figure></li><li><p><strong>选择硬盘</strong>：</p><ul><li><strong>母碟硬盘</strong>：选择原始硬盘（如 <code>/dev/sda</code>）。</li><li><strong>目标硬盘</strong>：选择新硬盘（如 <code>/dev/sdb</code>）。</li></ul></li><li><p><strong>克隆选项</strong>：<br> 需要进入专家模式才能看到，一般直接新手模式默认即可。</p></li><li><p><strong>执行克隆</strong>：</p><ul><li>确认提示信息后输入 <code>y</code>，等待完成。</li><li>克隆结束后关机，移除旧硬盘并测试新硬盘（主要是查看能不能启动进入系统，若能进入一般不会有问题，而且一般都能进入因为Clonezilla是高精确的块对块克隆）。</li></ul></li></ol><hr><h3 id="两种模式对比："><a href="#两种模式对比：" class="headerlink" title="两种模式对比："></a><strong>两种模式对比</strong>：</h3><table><thead><tr><th><strong>模式</strong></th><th>特点</th></tr></thead><tbody><tr><td>备份镜像</td><td>方便多机部署也可以用于留档</td></tr><tr><td>直接克隆</td><td>换硬盘快速迁移无需恢复过程</td></tr></tbody></table><hr><h3 id="Btrfs务必注意："><a href="#Btrfs务必注意：" class="headerlink" title="Btrfs务必注意："></a><strong>Btrfs务必注意</strong>：</h3><p>对Btrfs直接进行Clonezilla克隆大概率会碰到一个边界错误，这是由于Btrfs本身使用一段时间后碎片化存储导致的，你需要执行<code>sudo btrfs balance start --full-balance /</code>来进行整理，但是这也算是一个风险操作要确保完整执行不能在执行时意外中断导致文件系统出错，并且在后续克隆时不能使用新手模式要进入专家模式勾选-p1支持所有文件系统但是效率降低的选项来确保顺利克隆（未勾选此选项可能导致文件系统无法识别的错误），其他步骤参照前文即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>技术分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Archlinux KDE体验优化总结</title>
    <link href="/2025/02/02/archlinux-optimization/"/>
    <url>/2025/02/02/archlinux-optimization/</url>
    
    <content type="html"><![CDATA[<p>打算开一个坑记录这么久以来的Archlinux系统性能和操作体验优化经验</p><p>本文章长期更新</p><hr><h2 id="软件优化"><a href="#软件优化" class="headerlink" title="软件优化"></a>软件优化</h2><h2 id="快捷键设置"><a href="#快捷键设置" class="headerlink" title="快捷键设置"></a>快捷键设置</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    
    <tags>
      
      <tag>技术分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>命令行编辑器的优雅新选择</title>
    <link href="/2024/12/13/zellij-helix/"/>
    <url>/2024/12/13/zellij-helix/</url>
    
    <content type="html"><![CDATA[<p>意外发现Zellij+Helix还挺好用的</p><p>避免了vim&#x2F;neovim的配置流程直接就能上手的轻量命令行开发环境</p><p>稍微了解一下二者的快捷键就能舒适码字了</p><p>甚至还都是rust出品</p><p>即刻尝试一下<a href="https://zellij.dev/">Zellij</a>和<a href="https://helix-editor.com/">Helix</a>吧!</p><p>&#x2F;&#x2F; 至于Helix没有文件树显示的方案，反正Helix选择文件挺方便的要文件树无非是希望编辑窗口居于窗口中央，倒是可以用watch和tree命令来代替还能手动设置哪些文件不用显示hhh</p><p><img src="/images/zellij-helix.jpg" alt="实际效果"></p>]]></content>
    
    
    
    <tags>
      
      <tag>技术分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>愿指引明路的苍蓝星永远为你闪耀</title>
    <link href="/2024/11/11/mhwi/"/>
    <url>/2024/11/11/mhwi/</url>
    
    <content type="html"><![CDATA[<p>使用东方Project软音源THFont简单重置的MHWI主题曲</p><p>雄关漫道真如铁，而今迈步从头越</p><iframe src="//player.bilibili.com/player.html?bvid=BV1WymmYNEAk&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="500"></iframe>]]></content>
    
    
    <categories>
      
      <category>Rearrangement</category>
      
    </categories>
    
    
    <tags>
      
      <tag>音乐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Archlinux的KDE Plasma优先启用Nvidia独立显卡和混合显卡配置指北</title>
    <link href="/2024/11/06/arch-nvidia/"/>
    <url>/2024/11/06/arch-nvidia/</url>
    
    <content type="html"><![CDATA[<p>本文将介绍在 <strong>X11</strong> 和 <strong>Wayland</strong> 两种会话下，如何在 KDE Plasma 中优先启用 Nvidia 独立显卡，并提供 I+N 混合显卡的配置方案。<strong>首先，请确保您已经正确安装了 Nvidia 驱动</strong>（如果非 Mainline 内核，请使用 <code>nvidia-dkms</code> 或 <code>nvidia-open-dkms</code> 版本）。</p><p><img src="/images/5364bba6d035326e82c53504dd53e7c2454454985.png" alt="Nvidia设置示意图"></p><h3 id="适用系统"><a href="#适用系统" class="headerlink" title="适用系统"></a>适用系统</h3><p>对于 <strong>CachyOS</strong> 或 <strong>EndeavourOS</strong> 等 Arch Linux 衍生版，这些配置大多开箱即用，但对于刚刚入坑 Arch Linux 且使用 KDE 的新手可能会遇到这样的问题：</p><ul><li>Nvidia 驱动已安装，<code>nvidia-smi</code> 输出正常</li><li>KDE 系统信息显示仍在使用核显，程序运行时也优先使用核显</li><li>导致某些应用（如浏览器、Blender）可能出现卡顿或掉帧现象</li></ul><p>这是因为 Arch Linux 的高自定义性，许多功能需要用户手动配置。以下是详细的解决方案。</p><hr><h2 id="配置-X11-下的-Nvidia-显卡优先"><a href="#配置-X11-下的-Nvidia-显卡优先" class="headerlink" title="配置 X11 下的 Nvidia 显卡优先"></a>配置 X11 下的 Nvidia 显卡优先</h2><p>可以通过配置 <code>/etc/X11/xorg.conf</code> 实现 Nvidia 独显输出。幸运的是，Nvidia 提供了自动生成配置文件的工具，用户无需手动编写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo nvidia-xconfig --prime<br></code></pre></td></tr></table></figure><p>该命令会根据硬件情况自动生成配置文件。执行后 <strong>重新登录会话</strong> 即可生效（即使是 Wayland 用户也可以执行一次此命令）。</p><p><img src="/images/1613f5602b203b38230f19699deb0219454454985.png" alt="X11 Nvidia配置"></p><hr><h2 id="配置-Wayland-下的-Nvidia-显卡优先"><a href="#配置-Wayland-下的-Nvidia-显卡优先" class="headerlink" title="配置 Wayland 下的 Nvidia 显卡优先"></a>配置 Wayland 下的 Nvidia 显卡优先</h2><p>在 Wayland 下优先启用 Nvidia 显卡的步骤如下：</p><ol><li><p>编辑 <strong>GRUB 配置</strong>文件：</p><p>打开 <code>/etc/default/grub</code> 文件，在 <code>GRUB_CMDLINE_LINUX_DEFAULT=&quot;&quot;</code> 中添加 <code>nvidia_drm.modeset=1</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">GRUB_CMDLINE_LINUX_DEFAULT=<span class="hljs-string">&quot;nvidia_drm.modeset=1&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>重新生成 grub 配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo grub-mkconfig -o /boot/grub/grub.cfg<br></code></pre></td></tr></table></figure></li><li><p>配置 <strong>Plasma 环境</strong>文件：</p><p>在 <code>~/.config/plasma-workspace/env/nvidia.sh</code> 中写入以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash </span><br><span class="hljs-built_in">export</span> __NV_PRIME_RENDER_OFFLOAD=1 <br><span class="hljs-built_in">export</span> __GLX_VENDOR_LIBRARY_NAME=nvidia<br></code></pre></td></tr></table></figure></li><li><p>保存并重启电脑，即可生效。</p></li></ol><p><img src="/images/b2054bbaf6197624d38cc2007d885fd1454454985.png" alt="Wayland Nvidia配置"></p><hr><h2 id="I-N-混合显卡方案"><a href="#I-N-混合显卡方案" class="headerlink" title="I+N 混合显卡方案"></a>I+N 混合显卡方案</h2><p>如果不希望全局启用独显，可以选择让大部分程序默认使用核显，而少数高性能需求的程序使用独显。这种方法能有效节省功耗，同时将独显资源集中分配给需要的程序（如 Steam 游戏、Blender 等）。缺点是每个程序需要手动配置启动项。</p><h3 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h3><ol><li><p>打开程序的 <code>.desktop</code> 启动文件：</p><p>位置可能在 <code>/usr/share/applications</code> 或 <code>~/.local/share/applications</code> 中。</p></li><li><p>在 <code>Exec=</code> 后添加 <code>prime-run</code> 参数。例如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">Exec=prime-run &lt;程序启动命令&gt;<br></code></pre></td></tr></table></figure><p><img src="/images/71a5357ef4bd808b10429bc2ea46cb6f454454985.png" alt="混合显卡配置示意图"></p></li></ol><h3 id="Vim-快捷配置"><a href="#Vim-快捷配置" class="headerlink" title="Vim 快捷配置"></a>Vim 快捷配置</h3><p>如果使用 Vim，可以使用以下快捷键快速批量替换 <code>Exec=</code> 为 <code>Exec=prime-run</code>：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">v -&gt; G -&gt; :s/Exec=/Exec=prime-run /g Enter -&gt; :<span class="hljs-keyword">wq</span> Enter<br></code></pre></td></tr></table></figure><hr><h2 id="让-Plasma-桌面也使用独显"><a href="#让-Plasma-桌面也使用独显" class="headerlink" title="让 Plasma 桌面也使用独显"></a>让 Plasma 桌面也使用独显</h2><p>如果希望 Plasma 桌面也通过独显运行，可以修改 Wayland 配置文件并删除第二行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash </span><br><span class="hljs-built_in">export</span> __GLX_VENDOR_LIBRARY_NAME=nvidia<br></code></pre></td></tr></table></figure><p>这样 Plasma 桌面会通过独显启动，其他程序则默认使用核显。</p><hr><p>希望以上经验能为有此需求的用户提供参考帮助。</p>]]></content>
    
    
    <categories>
      
      <category>技术分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Overleaf Toolkit踩坑记录</title>
    <link href="/2024/11/06/overleaf/"/>
    <url>/2024/11/06/overleaf/</url>
    
    <content type="html"><![CDATA[<p>在安装 Overleaf Toolkit 时，表面上看起来很简单只要执行一些脚本就行，但是在某地区网络环境下还是遇到了一些问题和困难，这里记录安装过程中的问题和解决方案，方便以后参考。</p><p>具体流程就不赘述了，先将访问<a href="https://github.com/overleaf/toolkit">Overleaf Toolkit官方仓库</a>将代码clone下来并按照手册执行即可。</p><h2 id="问题一：无法-Pull-Mongo、Redis-和-Sharelatex-镜像"><a href="#问题一：无法-Pull-Mongo、Redis-和-Sharelatex-镜像" class="headerlink" title="问题一：无法 Pull Mongo、Redis 和 Sharelatex 镜像"></a>问题一：无法 Pull Mongo、Redis 和 Sharelatex 镜像</h2><p>在执行 <code>bin/up</code> 脚本启动服务时，发现 Mongo、Redis 和 Sharelatex 镜像无法拉取。主要原因是 Docker 在国内网络环境中，直接访问 Docker Hub 可能会被限制，导致拉取镜像失败。</p><p>截至这篇博客编写时网上提供的镜像均无法解决只能使用代理。</p><h3 id="解决方案：为-Docker-设置代理"><a href="#解决方案：为-Docker-设置代理" class="headerlink" title="解决方案：为 Docker 设置代理"></a>解决方案：为 Docker 设置代理</h3><p>通过配置 Docker 的代理，可以解决拉取镜像受限的问题。步骤如下：</p><ol><li><p>创建一个 <code>systemd</code> 服务文件，为 Docker 设置代理。</p></li><li><p>编辑 <code>/etc/systemd/system/docker.service.d/proxy.conf</code> 文件，添加以下内容（确保已经设置了代理服务器）：</p> <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Service]</span><br><span class="hljs-attr">Environment</span>=<span class="hljs-string">&quot;HTTP_PROXY=http://&lt;your-proxy-server&gt;:&lt;port&gt;&quot;</span><br><span class="hljs-attr">Environment</span>=<span class="hljs-string">&quot;HTTPS_PROXY=http://&lt;your-proxy-server&gt;:&lt;port&gt;&quot;</span><br><span class="hljs-attr">Environment</span>=<span class="hljs-string">&quot;NO_PROXY=localhost,127.0.0.1&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>重新加载 <code>systemd</code> 配置并重启 Docker：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl daemon-reload<br>sudo systemctl restart docker<br></code></pre></td></tr></table></figure></li><li><p>重启 Docker 后再次执行 <code>sudo ./up</code>，此时应该可以正常拉取 Mongo、Redis 和 Sharelatex 的镜像。等待执行完成即可。</p></li></ol><hr><h2 id="问题二：外部机器无法访问-Overleaf-Web-服务"><a href="#问题二：外部机器无法访问-Overleaf-Web-服务" class="headerlink" title="问题二：外部机器无法访问 Overleaf Web 服务"></a>问题二：外部机器无法访问 Overleaf Web 服务</h2><p>先确认ipv4和ipv6转发功能没有问题，但是依旧出现只能本机访问127.0.0.1，其他方式均无法访问，甚至nmap扫描端口也发现并未开放sharelatex端口，可以通过修改docker-compose配置文件解决。</p><p>注意到在默认的 <code>lib/docker-compose.base.yml</code> 配置中，Overleaf Web 服务的端口映射方式为 <code>&quot;$&#123;OVERLEAF_LISTEN_IP:-127.0.0.1&#125;:$&#123;OVERLEAF_PORT:-80&#125;:80&quot;</code>。</p><h3 id="解决方案：修改端口映射"><a href="#解决方案：修改端口映射" class="headerlink" title="解决方案：修改端口映射"></a>解决方案：修改端口映射</h3><p>在 <code>docker-compose.base.yml</code> 文件中，删除 <code>$&#123;OVERLEAF_LISTEN_IP:-127.0.0.1&#125;</code> 前缀，将 <code>&quot;$&#123;OVERLEAF_LISTEN_IP:-127.0.0.1&#125;:$&#123;OVERLEAF_PORT:-80&#125;:80&quot;</code> 修改为 <code>&quot;$&#123;OVERLEAF_PORT:-80&#125;:80&quot;</code>。这样可以使 Docker 将 Overleaf 的 Web 服务端口暴露给所有网络接口，从而允许外部机器访问。</p><p>修改后的 <code>docker-compose.base.yml</code> 端口映射配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">services:</span><br><br>    <span class="hljs-attr">sharelatex:</span><br>        <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">&quot;$&#123;IMAGE&#125;&quot;</span><br>        <span class="hljs-attr">container_name:</span> <span class="hljs-string">sharelatex</span><br>        <span class="hljs-attr">volumes:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;$&#123;OVERLEAF_DATA_PATH&#125;:$&#123;OVERLEAF_IN_CONTAINER_DATA_PATH&#125;&quot;</span><br>        <span class="hljs-attr">ports:</span><br>            <span class="hljs-comment">#- &quot;$&#123;OVERLEAF_LISTEN_IP:-127.0.0.1&#125;:$&#123;OVERLEAF_PORT:-80&#125;:80&quot;</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;$&#123;OVERLEAF_PORT:-80&#125;:80&quot;</span><br>        <span class="hljs-attr">environment:</span><br>          <span class="hljs-attr">GIT_BRIDGE_ENABLED:</span> <span class="hljs-string">&quot;$&#123;GIT_BRIDGE_ENABLED&#125;&quot;</span><br>          <span class="hljs-attr">GIT_BRIDGE_HOST:</span> <span class="hljs-string">&quot;git-bridge&quot;</span><br>          <span class="hljs-attr">GIT_BRIDGE_PORT:</span> <span class="hljs-string">&quot;8000&quot;</span><br>          <span class="hljs-attr">REDIS_HOST:</span> <span class="hljs-string">&quot;$&#123;REDIS_HOST&#125;&quot;</span><br>          <span class="hljs-attr">REDIS_PORT:</span> <span class="hljs-string">&quot;$&#123;REDIS_PORT&#125;&quot;</span><br>          <span class="hljs-attr">V1_HISTORY_URL:</span> <span class="hljs-string">&quot;http://sharelatex:3100/api&quot;</span><br>        <span class="hljs-attr">env_file:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">../config/variables.env</span><br>        <span class="hljs-attr">stop_grace_period:</span> <span class="hljs-string">60s</span><br></code></pre></td></tr></table></figure><p>完成修改后，重新启动 Docker 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo ./start<br></code></pre></td></tr></table></figure><p>现在，外部机器可以通过服务器的 IP 地址加端口 <code>&#123;Overleaf_Port&#125;</code> 访问 Overleaf Web 服务。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次安装 Overleaf Toolkit 时，主要遇到的两个问题分别是镜像拉取失败和端口映射受限。通过为 Docker 设置代理解决了拉取镜像的问题，而通过修改 <code>docker-compose.base.yml</code> 中的端口映射使外部设备可以访问 Overleaf 服务。</p><p>可以在这里参考我的本地<a href="https://overleaf.hifuu.ink/">Overleaf</a>效果，注意安装完后还需要配置latex包和中文字体。</p><p>这篇记录希望能为遇到类似问题的朋友提供帮助。</p>]]></content>
    
    
    <categories>
      
      <category>技术分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>时隔一年再次拿起数位板能画出什么东西</title>
    <link href="/2024/11/04/loopers/"/>
    <url>/2024/11/04/loopers/</url>
    
    <content type="html"><![CDATA[<p>如题，前段时间推完LOOPERS的时候有感而发对着画了张海报</p><p>时隔一年，终于又拿起了数位板</p><p><img src="/images/20241027_222225.png" alt="LOOPERS" title="LOOPERS"></p>]]></content>
    
    
    
    <tags>
      
      <tag>板绘</tag>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客更新记录</title>
    <link href="/2024/11/04/BlogUpdate/"/>
    <url>/2024/11/04/BlogUpdate/</url>
    
    <content type="html"><![CDATA[<ul><li>博客主题更新为 <code>Fluid</code> 主题，原主题为 <code>Next</code></li><li>更新了访问地址为 <code>https://blog.hifuu.ink</code></li><li>新增了 <code>About</code> 页面</li><li>新增了 <code>友链</code> 页面</li><li>完善页面布局</li></ul>]]></content>
    
    
    <categories>
      
      <category>更新</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vocaloid调教-晴天(洛天依V4)</title>
    <link href="/2024/11/04/Vocaloid%E8%B0%83%E6%95%99-%E6%99%B4%E5%A4%A9/"/>
    <url>/2024/11/04/Vocaloid%E8%B0%83%E6%95%99-%E6%99%B4%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<p>其实是今年年初的作品想起来可以搬上来，这是我调教的第一首v曲。</p><p>“故事的小黄花，从出生那年就飘着…”</p><iframe src="//player.bilibili.com/player.html?bvid=BV1xzPteRErF&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="500"></iframe>]]></content>
    
    
    <categories>
      
      <category>Vocaloid</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vocaloid</tag>
      
      <tag>音乐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gentle Jena</title>
    <link href="/2024/10/30/GentleJena/"/>
    <url>/2024/10/30/GentleJena/</url>
    
    <content type="html"><![CDATA[<p>很喜欢的一首曲子<br>顺便测试一下视频上传<br>以后随缘更新各种乱七八糟的东西。。</p><video controls width="600" height="400">  <source src="https://ik.imagekit.io/7grujzz8i/2024-09-22%2014-05-02.mp4?updatedAt=1738496025016" type="video/mp4" width="50%"></video>]]></content>
    
    
    <categories>
      
      <category>Rearrangement</category>
      
    </categories>
    
    
    <tags>
      
      <tag>音乐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原来我还有个博客</title>
    <link href="/2024/06/03/%E5%8E%9F%E6%9D%A5%E6%88%91%E8%BF%98%E6%9C%89%E4%B8%AA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2024/06/03/%E5%8E%9F%E6%9D%A5%E6%88%91%E8%BF%98%E6%9C%89%E4%B8%AA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>哎呦我去，原来我还有个博客，这么久都没有更新了，之前还说要养成写东西的习惯最近属实忙忘记了哈哈哈。(然而大二了依旧没养成)</p><p>不过忙归忙虽然大一被迫浪费时间去做了一些对专业技术无益的事情，但是思路确实越忙越清楚了，知道自己该去学什么怎么学了，也不再受某些出生干扰了，这周还要出个差，下周又要英语六级+期末考试，真是忙完一阵又一阵。</p><p>先这样吧，今天总得来说还是很爽的，考完电工如释重负，以后有时间再记录记录生活，暑假前再写个学期总结，晚安～</p>]]></content>
    
    
    
    <tags>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12月30-31日进度报告</title>
    <link href="/2023/12/31/12%E6%9C%8831%E6%97%A5%E8%BF%9B%E5%BA%A6%E6%8A%A5%E5%91%8A/"/>
    <url>/2023/12/31/12%E6%9C%8831%E6%97%A5%E8%BF%9B%E5%BA%A6%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="12月30-31日"><a href="#12月30-31日" class="headerlink" title="12月30-31日"></a>12月30-31日</h2><p>OpenCAEPoro 小组（黄<strong>，梁</strong>，程<strong>，刘</strong>）</p><ol><li>服务器上的Opencaeporo改用nvhpc编译器编译以支持cuda;</li><li>收集运行数据用于proposal绘制图表;</li><li>继续尝试优化，同时已经查阅收集了一些相关资料以尽量理解相关含义便于工作开展.</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12月28日进度报告</title>
    <link href="/2023/12/28/12%E6%9C%8828%E6%97%A5%E8%BF%9B%E5%BA%A6%E6%8A%A5%E5%91%8A/"/>
    <url>/2023/12/28/12%E6%9C%8828%E6%97%A5%E8%BF%9B%E5%BA%A6%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="12月28日"><a href="#12月28日" class="headerlink" title="12月28日"></a>12月28日</h2><p>OpenCAEPoro 小组（黄<strong>，梁</strong>，程<strong>，刘</strong>）</p><ol><li>各组员继续进行优化工作,部分函数完成cuda移植，取得一定优化效果</li><li>继续学习openacc及cuda相关知识</li><li>搜集多孔介质流动模拟与opencaeporo相关论文资料为proposal做准备</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12月20日工作记录</title>
    <link href="/2023/12/20/12%E6%9C%8820%E6%97%A5%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/12/20/12%E6%9C%8820%E6%97%A5%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="12月20日"><a href="#12月20日" class="headerlink" title="12月20日"></a>12月20日</h2><p>OpenCAEPoro 小组（黄<strong>，梁</strong>，程**）</p><ol><li>阅读代码，开展优化工作,初步使用openacc完成petsc_solver的优化，取得一定优化效果</li></ol><blockquote><p>优化方向基本确定为OpenMP&#x2F;OpenACC并行化+cuda移植</p></blockquote><ol start="2"><li>赛题环境汇总，目前各组工作有序开展，CentOS 7符合要求暂未发现更换系统需求</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12月19日工作记录</title>
    <link href="/2023/12/19/12%E6%9C%8819%E6%97%A5%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/12/19/12%E6%9C%8819%E6%97%A5%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="12月18日"><a href="#12月18日" class="headerlink" title="12月18日"></a>12月18日</h2><ol><li>彻底完成opencaeporo安装部署，本地和服务器均已安装，明天正式开始调优工作;</li><li>学习cuda编程.</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12月18日工作记录</title>
    <link href="/2023/12/18/12%E6%9C%8818%E6%97%A5%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/12/18/12%E6%9C%8818%E6%97%A5%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="12月18日"><a href="#12月18日" class="headerlink" title="12月18日"></a>12月18日</h2><ol><li>初步了解opencaeporo，尝试在本地docker环境使用gcc完成编译安装，目前完成各项依赖安装，由于晚上停电计划明天开始编译安装opencaeporo本体并在本地调优;</li><li>协助Neko组完成任务;</li><li>找出spack存在网络原因无法下载时的手动解决方案.</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12月16-17日工作记录</title>
    <link href="/2023/12/17/12%E6%9C%8816-17%E6%97%A5%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/12/17/12%E6%9C%8816-17%E6%97%A5%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="12月16-17日"><a href="#12月16-17日" class="headerlink" title="12月16-17日"></a>12月16-17日</h2><ol><li>四级考试</li><li>自学cuda，openacc，了解GPU架构知识</li><li>参加超算队启动会</li><li>大计和高数期中考试</li><li>研究spack使用</li><li>学习cuda编程</li><li>补作业</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>梦开始的地方</title>
    <link href="/2023/12/06/%E6%A2%A6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%9C%B0%E6%96%B9/"/>
    <url>/2023/12/06/%E6%A2%A6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%9C%B0%E6%96%B9/</url>
    
    <content type="html"><![CDATA[<p>不知不觉已经高中毕业快半年了，现在在NUDT的生活还算适应吧，交到了一些很有趣的朋友并且在技术方面取得了一定突破（很期待明年的asc2024呢），今天看到华科一位学长的博客突然想起我还没好好搭建过自己的Blog，于是心血来潮搞了下我的Github Pages。</p><p>今后会在这里更新记录自己的生活，学习，工作，以及一些想法，希望能坚持下来吧。</p><blockquote><p>P.S.最近我都经历了些什么:</p><ol><li>时长21天军训，认识了一群很可爱的班长（尤其是负责我们5班6班的英子），初步和队里的同学了解;</li><li>学习了一些C++基础，在洛谷上刷了不少算法题;</li><li>ACM招新赛被薄纱，差一题进入校队;</li><li>对算法竞赛感到疑惑，尝试学习Flutter和操作系统开阔视野;</li><li>入坑战地，爽爽爽;</li><li>被一位巨强的学长发掘，加入NUDT超算队;</li><li>面临三个考试周，熬过去就是胜利;</li></ol></blockquote><p>虽然天天早八满课很不爽，但是平时还是可以学习自己想学的技术周末也可以打游戏感觉还行吧，我还是相信NUDT，既来之则安之。</p><p>这里，毕竟是我梦开始的地方。</p><blockquote><p>胸怀祖国，团结协作，志在高峰，奋勇拼搏!</p></blockquote><p>今天是2023年12月6日，加油！</p><hr><p>现在是2024年10月30日，距离Monster Hunter: Wilds公测不到两天，如今再看看自己以前写的东西觉得自己像个傻逼</p><p>傻孩子们，快逃啊!</p>]]></content>
    
    
    
    <tags>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Welcome to CGH0S7&#39;s Blog</title>
    <link href="/2023/12/06/CGH0S7-s-Blog/"/>
    <url>/2023/12/06/CGH0S7-s-Blog/</url>
    
    <content type="html"><![CDATA[<p>Hello World !</p>]]></content>
    
    
    
    <tags>
      
      <tag>TEST</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
